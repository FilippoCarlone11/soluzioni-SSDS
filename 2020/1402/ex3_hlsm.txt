LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY hlsm IS
PORT(	clk, rst, b, e, d: IN std_logic;
	i : IN std_logic_vector(15 DOWNTO 0);
	o : OUT std_logic_vector(15 DOWNTO 0)
);
END hlsm;

ARCHITECTURE behav OF hlsm IS
TYPE stateType IS (idle, value, encrypt ,decrypt);
SIGNAL currentState, nextState : stateType;
SIGNAL offset, next_offset, enc, next_enc : std_logic_vector(15 DOWNTO 0);
 
BEGIN

seqProc: PROCESS(rst, clk) BEGIN
	IF(rst = '1') THEN
		currentState <= idle;
		offset <= (OTHERS => '0');
		enc <= (OTHERS => '0');
	ELSIF(rising_edge(clk)) THEN
		currentState<= nextState;
		offset <= next_offset;
		enc <= next_enc;
	END IF;
END PROCESS;

combProc: PROCESS(currentState, b, e, d, i) BEGIN
	nextState <= currentState;
	next_offset <= offset;
	next_enc <= enc;
	o <= (OTHERS => '0');
	CASE currentState IS
		WHEN idle =>
			IF( b = '1') THEN
				next_offset <= i;
				nextState <= value;
			ELSE
				nextState <= idle;
			END IF;
		WHEN value =>
			IF(e = '1') THEN
				next_enc <= std_logic_vector(resize(unsigned(i)+unsigned(offset), 16));
				next_state <= encrypt;
			ELSE
				nextState <= value;
			END IF;
		WHEN encrypt =>
			o <= enc;
			IF(d = '1') THEN
				nextState <= decrypt;
				next_enc <= std_logic_vector(resize(unsigned(i)-unsigned(offset), 16));
			ELSE
				nextState <= encrypt;
			END IF;
		WHEN decrypt =>
			o <= enc;
			nextState <= idle;
		WHEN OTHERS =>
			nextState <= idle;
	END CASE;
END PROCESS;

END behav;